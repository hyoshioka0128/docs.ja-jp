---
title: アーキテクチャのデプロイ方法-サーバーレスアプリ
description: エンタープライズアーキテクチャがクラウドにデプロイされるさまざまな方法のガイド。 IaaS、PaaS、コンテナー、サーバーレスを比較しています。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: 4cc8442509fc8a0e2cc0eb797365423458e77684
ms.sourcegitcommit: 8a0fe8a2227af612f8b8941bdb8b19d6268748e7
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/03/2019
ms.locfileid: "71834337"
---
# <a name="architecture-deployment-approaches"></a>アーキテクチャのデプロイ方法

ビジネスアプリケーションの設計に使用されるアーキテクチャアプローチに関係なく、これらのアプリケーションの実装や配置は異なる場合があります。 企業は、物理ハードウェアからサーバーレス機能に至るまで、あらゆるアプリケーションでアプリケーションをホストしています。

## <a name="n-tier-applications"></a>N 層アプリケーション

[N 層アーキテクチャパターン](https://docs.microsoft.com/azure/architecture/guide/architecture-styles/n-tier)は成熟したアーキテクチャであり、さまざまな論理層を別々の物理層に分けるアプリケーションを単に指します。 N 層アーキテクチャは、N 層アーキテクチャの物理的な実装です。 このアーキテクチャの最も一般的な実装は次のとおりです。

* Web アプリなどのプレゼンテーション層。
* API またはデータアクセス層 (REST API など)。
* SQL データベースなどのデータ層。

![N 層アーキテクチャ](./media/n-tier-architecture.png)

N 層ソリューションには次の特性があります。

* 通常、プロジェクトは階層に合わせて調整されます。
* テストのアプローチは、レベルによって異なる場合があります。
* 階層は抽象レイヤーを提供します。たとえば、プレゼンテーション層は、通常、データ層の実装の詳細を意識しません。
* 通常、レイヤーは隣接するレイヤーとのみやり取りします。
* リリースは多くの場合、プロジェクトで管理されているため、階層レベルで管理されます。 単純な API 変更では、中間層全体の新しいリリースが必要になる場合があります。

このアプローチには、次のようないくつかの利点があります。

* データベースの分離 (多くの場合、フロントエンドはデータベースバックエンドに直接アクセスできません)。
* API の再利用 (モバイル、デスクトップ、web アプリクライアントなど) は、すべて同じ Api を再利用できます。
* 階層を互いに独立してスケールアウトする機能。
* リファクタリングの分離: 他の層に影響を与えることなく、1つの層をリファクターすることができます。

## <a name="on-premises-and-infrastructure-as-a-service-iaas"></a>オンプレミスとサービスとしてのインフラストラクチャ (IaaS)

アプリケーションをホストする従来のアプローチでは、ハードウェアを購入し、オペレーティングシステムを含むすべてのソフトウェアインストールを管理する必要があります。 もともと、これは高価なデータセンターと物理ハードウェアに関係していました。 物理ハードウェアの運用には、次のような課題があります。

* "ケース内" またはピーク時の需要シナリオに対して、余分に購入する必要があります。
* ハードウェアへの物理的なアクセスをセキュリティで保護する。
* ハードウェア障害 (ディスク障害など) の責任。
* 高密度.
* ルーターとロードバランサーを構成する。
* 電力の冗長性。
* ソフトウェアアクセスをセキュリティで保護する。

![IaaS のアプローチ](./media/iaas-approach.png)

"仮想マシン" を使用してハードウェアを仮想化すると、サービスとしてのインフラストラクチャ (IaaS) が有効になります。 ホストコンピューターは、実際には、メモリ、CPU、およびストレージに割り当てられたインスタンスにリソースを提供するために、効果的にパーティション分割されます。 チームは必要な Vm をプロビジョニングし、関連付けられているネットワークとストレージへのアクセスを構成します。

詳細については、「[仮想マシン N 層リファレンスアーキテクチャ](https://docs.microsoft.com/azure/architecture/reference-architectures/virtual-machines-windows/n-tier)」を参照してください。

仮想化とサービスとしてのインフラストラクチャ (IaaS) は多くの懸念事項に対応していますが、インフラストラクチャチームの担当者にも多くの責任があります。 チームは、オペレーティングシステムのバージョンを管理し、セキュリティ更新プログラムを適用し、ターゲットコンピューターにサードパーティの依存関係をインストールします。 多くの場合、アプリの動作はテスト環境と比較して実稼働コンピューターで異なります。 さまざまな依存関係のバージョンや OS SKU レベルによって問題が発生します。 多くの組織は N 層アプリケーションをこれらのターゲットにデプロイしますが、多くの企業では、[サービスとし](#platform-as-a-service-paas)てのプラットフォームなどのクラウドネイティブモデルにデプロイすることにメリットがあります。 拡張性と回復性のためにスケールアウトする必要があるため、マイクロサービスを使用したアーキテクチャがより困難になります。

詳細については、「[仮想マシン](https://docs.microsoft.com/azure/virtual-machines/)」を参照してください。

## <a name="platform-as-a-service-paas"></a>サービスとしてのプラットフォーム (PaaS)

サービスとしてのプラットフォーム (PaaS) は、開発者が直接接続できるように構成されたソリューションを提供します。 PaaS は、管理されたホスティングのためのもう1つの用語です。 これにより、基本オペレーティングシステム、セキュリティパッチ、および多くの場合、サードパーティの依存関係を管理する必要がなくなります。 プラットフォームの例としては、web アプリケーション、データベース、モバイルバックエンドなどがあります。

PaaS は、IaaS に共通する課題に対処します。 PaaS を使用すると、開発者は、デプロイ方法ではなく、コードまたはデータベーススキーマに集中できます。 PaaS の利点は次のとおりです。

* アイドル状態のマシンへの投資のオーバーヘッドを解消する、使用モデルの料金が発生します。
* ダイレクトデプロイと改善された DevOps、継続的インテグレーション (CI)、継続的デリバリー (CD) パイプライン。
* 自動アップグレード、更新、およびセキュリティパッチ。
* プッシュボタンのスケールアウトとスケールアップ (エラスティックスケール)。

従来、PaaS の主な欠点はベンダーのロックインでした。 たとえば、一部の PaaS プロバイダーは、ASP.NET、node.js、またはその他の特定の言語とプラットフォームのみをサポートしています。 Azure App Service のような製品では、複数のプラットフォームに対応し、web アプリをホストするためのさまざまな言語とフレームワークをサポートしています。

![サービスとしてのプラットフォームのアーキテクチャ](./media/paas-architecture.png)

## <a name="software-as-a-service-saas"></a>サービスとしてのソフトウェア (SaaS)

サービスとしてのソフトウェアまたは SaaS は一元的にホストされ、ローカルのインストールやプロビジョニングなしで利用できます。 SaaS は、多くの場合、ソフトウェアを展開するためのプラットフォームとして PaaS の上にホストされます。 SaaS は、既存のソフトウェアを実行して接続するためのサービスを提供します。 SaaS は多くの場合、業界および垂直に固有です。 SaaS は多くの場合、クライアント/サーバーモデルを提供します。 最新の SaaS サービスでは、クライアントに web ベースのアプリを使用します。 企業は通常、SaaS をライセンスオファリングのビジネスソリューションとして検討しています。 多くの場合、アプリケーションのスケーラビリティと保守性のためにアーキテクチャの考慮事項として実装されることはありません。 実際、ほとんどの SaaS ソリューションは、IaaS、PaaS、またはサーバーレスバックエンド上に構築されています。

SaaS の詳細については、[サンプルアプリケーション](https://docs.microsoft.com/azure/sql-database/saas-tenancy-welcome-wingtip-tickets-app)を参照してください。

## <a name="containers-and-functions-as-a-service-faas"></a>サービスとしてのコンテナーと関数 (FaaS)

コンテナーは、IaaS のオーバーヘッドを発生させることなく、PaaS に似たメリットを実現する、興味深いソリューションです。 コンテナーは基本的に、一意のアプリケーションを実行するために必要なベアメタルを含むランタイムです。 ホストオペレーティングシステムのカーネルまたはコア部分、およびストレージなどのサービスは、ホスト間で共有されます。 共有カーネルを使用すると、コンテナーを軽量にすることができます (通常の仮想マシンのギガバイトサイズと比較して、サイズがわずかメガバイトになります)。 既に実行されているホストでは、コンテナーをすばやく起動して高可用性を実現できます。 コンテナーを迅速にスピンアップする機能により、回復性のレイヤーも追加されます。 Docker は、コンテナーの一般的な実装の1つです。

コンテナーの利点は次のとおりです。

* 軽量でポータブル
* 自己完結型であるため、依存関係をインストールする必要はありません
* ホストに関係なく一貫した環境を提供する (クラウドサーバーと同じノート pc でのみ実行されます)
* スケールアウトのために迅速にプロビジョニング可能
* 障害から回復するには、すぐに再起動できます

コンテナーは、コンテナーホスト上で実行されます (これは、ベアメタルコンピューターまたは仮想マシン上で実行される可能性があります)。 同じコンテナーの複数のコンテナーまたはインスタンスが、1つのホストで実行される場合があります。 真のフェールオーバーと回復性を実現するには、コンテナーをホスト間でスケーリングする必要があります。

Docker コンテナーの詳細については、「 [docker とは](../microservices/container-docker-introduction/docker-defined.md)」を参照してください。

通常、ホスト間でコンテナーを管理するには、Kubernetes などのオーケストレーションツールが必要です。 オーケストレーションソリューションを構成して管理すると、プロジェクトのオーバーヘッドと複雑さが増える可能性があります。 幸いなことに、多くのクラウドプロバイダーでは、コンテナーの管理を簡略化するために、PaaS ソリューションによってオーケストレーションサービスを提供しています。

次の図は、Kubernetes のインストール例を示しています。 インストールのノードでは、スケールアウトとフェールオーバーを行います。 マスターサーバーで管理されている Docker コンテナーインスタンスを実行します。 *Kubelet*は、Kubernetes から Docker にコマンドを中継するクライアントです。

![Kubernetes](./media/kubernetes-example.png)

オーケストレーションの詳細については、「 [Kubernetes On Azure](https://docs.microsoft.com/azure/aks/intro-kubernetes)」を参照してください。

サービスとしての機能 (FaaS) は、サーバーレスに似た専用のコンテナーサービスです。 [Openfaas](https://github.com/openfaas/faas)と呼ばれる faas の特定の実装は、サーバーレス機能を提供するためにコンテナーの上に配置されます。 OpenFaaS には、コードを実行するために必要なすべてのコンテナーの依存関係をパッケージ化するテンプレートが用意されています。 テンプレートを使用すると、コードを機能単位としてデプロイするプロセスが簡単になります。 Openfaas は、既存のインフラストラクチャを使用できるため、既にコンテナーとオーケストレーター含んでいるアーキテクチャをターゲットとしています。 サーバーレス機能を提供しますが、Docker と orchestrator を使用する必要があります。

## <a name="serverless"></a>サーバー

サーバーレスアーキテクチャを使用すると、コードとそのホスティング環境を明確に分離できます。 *トリガー*によって呼び出される*関数*にコードを実装します。 その関数が終了すると、必要なすべてのリソースが解放される可能性があります。 トリガーには、手動、時間指定のプロセス、HTTP 要求、またはファイルのアップロードがあります。 トリガーの結果は、コードの実行です。 サーバーレスプラットフォームはさまざまですが、ほとんどの場合、定義済みの Api とバインドにアクセスして、データベースへの書き込みや結果のキューなどのタスクを効率化できます。

サーバーレスは、コードに集中するためのホスト環境の抽象化に大きく依存するアーキテクチャです。 サーバーの数が*少ない*と考えることができます。

コンテナーソリューションを使用すると、開発者は既存のビルドスクリプトを使用して、サーバーレス対応のイメージにコードを発行できます。 その他の実装では、既存の PaaS ソリューションを使用してスケーラブルなアーキテクチャを提供します。

抽象化は、DevOps チームがサーバーや特定のコンテナーをプロビジョニングまたは管理する必要がないことを意味します。 サーバーレスプラットフォームは、関連する SDK を使用してビルドされたスクリプトまたはパッケージ実行可能ファイルとしてコードをホストし、コードを拡張するために必要なリソースを割り当てます。

次の図は、4つのサーバーレスコンポーネントを図で示しています。 HTTP 要求が発生すると、チェックアウト API コードが実行されます。 Checkout API はデータベースにコードを挿入し、insert は他のいくつかの関数を実行して、タスクの計算や注文の実行などのタスクを実行します。

![サーバーレス実装](./media/serverless-implementation.png)

サーバーレスの利点は次のとおりです。

* **高密度。** 同じサーバーレスコードの多くのインスタンスは、コンテナーまたは仮想マシンと比較して同じホスト上で実行できます。 インスタンスは複数のホストにまたがるスケールアウトと回復性を備えています。
* **マイクロ請求**。 ほとんどのサーバーレスプロバイダーは、サーバーレス実行に基づいて課金されるため、特定のシナリオで大幅なコスト削減を実現します。
* **インスタントスケール**。 サーバーレスは、ワークロードを自動的かつ迅速に一致させるために拡張できます。
* **市場投入までの時間を短縮**開発者はコードに重点を置いて、サーバーレスプラットフォームに直接デプロイします。 コンポーネントは、互いに独立して解放できます。

サーバーレスは、多くの場合、compute のコンテキストで説明されていますが、データにも適用できます。 たとえば、 [AZURE SQL](https://docs.microsoft.com/azure/sql-database)と[Cosmos DB](https://docs.microsoft.com/azure/cosmos-db)はどちらも、ホストコンピューターまたはクラスターの構成を必要としないクラウドデータベースを提供します。 この本は、サーバーレスコンピューティングに焦点を当てています。

## <a name="summary"></a>まとめ

ハイブリッドアプローチを含め、アーキテクチャには幅広い選択肢があります。 サーバーレスでは、制御と移植性を犠牲にして、アプリケーション機能のアプローチ、管理、コストを簡略化します。 ただし、多くのサーバーレスプラットフォームでは、ソリューションを微調整するために構成を公開しています。 また、適切なプログラミング手法を使用すると、移植性の高いコードとサーバーレスプラットフォームのロックインが向上する可能性もあります。 次の表は、アーキテクチャのアプローチを並べて示しています。 スケールのニーズに基づいてサーバーレスを選択し、ランタイムを管理するかどうか、およびワークロードを小さなコンポーネントに分割することができるかどうかを選択します。 次の章では、サーバーレスおよびその他の意思決定点に関する潜在的な課題について説明します。

|         |IaaS     |PaaS     |コンテナー|サーバー|
|---------|---------|---------|---------|----------|
|**スケール**|VM       |Instance |アプリ      |関数  |
|**抽出**|ハードウェア|プラットフォーム|OS ホスト|ランタイム   |
|**間隔** |VM       |Project  |イメージ    |コード      |
|**有効期間**|前月|日数から月|分から日|ミリ秒 (分)|
|**負っ**|アプリケーション、依存関係、ランタイム、およびオペレーティングシステム|アプリケーションと依存関係|アプリケーション、依存関係、およびランタイム|関数

* **Scale**は、アプリケーションのスケーリングに使用される単位を示します。
* **抽象化**とは、実装によって抽象化されたレイヤーを指します。
* **単位**とは、展開される対象の範囲を指します。
* **有効期間**とは、特定のインスタンスの一般的なランタイムを指します。
* **責任**とは、アプリケーションを構築、展開、および保守するためのオーバーヘッドを指します。

次の章では、サーバーレスアーキテクチャ、ユースケース、および設計パターンに焦点を当てます。

## <a name="recommended-resources"></a>推奨されるリソース

* [Azure アプリケーションアーキテクチャガイド](https://docs.microsoft.com/azure/architecture/guide/)
* [Azure Cosmos DB](https://docs.microsoft.com/azure/cosmos-db)
* [Azure SQL](https://docs.microsoft.com/azure/sql-database)
* [N 層アーキテクチャパターン](https://docs.microsoft.com/azure/architecture/guide/architecture-styles/n-tier)
* [Azure での Kubernetes](https://docs.microsoft.com/azure/aks/intro-kubernetes)
* [マイクロサービス](https://docs.microsoft.com/azure/architecture/guide/architecture-styles/microservices)
* [仮想マシン N 層リファレンスアーキテクチャ](https://docs.microsoft.com/azure/architecture/reference-architectures/virtual-machines-windows/n-tier)
* [仮想マシン](https://docs.microsoft.com/azure/virtual-machines/)
* [Docker について](../microservices/container-docker-introduction/docker-defined.md)
* [Wingtip チケット SaaS アプリケーション](https://docs.microsoft.com/azure/sql-database/saas-tenancy-welcome-wingtip-tickets-app)

>[!div class="step-by-step"]
>[前へ](architecture-approaches.md)
>[次へ](serverless-architecture.md)
