---
title: ガベージ コレクションの基礎
description: ガベージ コレクターのしくみと、パフォーマンスを最適化するための構成方法について説明します。
ms.date: 11/15/2019
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background
- garbage collection, concurrent
- garbage collection, server
- garbage collection, workstation
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
ms.openlocfilehash: ea8aef03d2f5837f35ecb31209e57853c0c8257b
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/22/2019
ms.locfileid: "74330415"
---
# <a name="fundamentals-of-garbage-collection"></a>ガベージ コレクションの基礎

共通言語ランタイム (CLR) では、自動メモリ マネージャーとしてガベージ コレクター (GC) を使用できます。 次のような利点があります。

- アプリケーションを開発するときにメモリを手動で解放する必要がありません。

- オブジェクトが効率的にマネージド ヒープに割り当てられます。

- 使用されなくなったオブジェクトが解放され、メモリがクリアされてその後の割り当てに使用できるようになります。 マネージド オブジェクトは自動的にクリーンな内容で開始されるため、コンストラクターでデータ フィールドごとに初期化する必要はありません。

- オブジェクトで別のオブジェクトの内容を使用できなくすることで、メモリの安全が確保されます。

この記事では、ガベージ コレクションの主要な概念について説明します。

## <a name="fundamentals-of-memory"></a>メモリの基礎

CLR のメモリに関する重要な概念の概要を以下に示します。

- 各プロセスは、分離された独自の仮想アドレス空間を持ちます。 同じコンピューターのすべてのプロセスが同じ物理メモリとページ ファイル (存在する場合) を共有します。

- 32 ビット コンピューターでは、各プロセスが既定で 2 GB のユーザー モード仮想アドレス空間を持ちます。

- アプリケーション開発者が操作するのは仮想アドレス空間だけで、直接物理メモリを操作することはありません。 マネージド ヒープの仮想メモリの割り当てと解放はガベージ コレクターによって行われます。

  ネイティブ コードを記述する場合は、Windows 関数を使用して仮想アドレス空間を操作します。 ネイティブ ヒープの仮想メモリの割り当てと解放はこれらの関数によって行われます。

- 仮想メモリには次の 3 つの状態があります。

  - 空き。 参照されていない、割り当てに使用できるメモリ ブロックです。

  - 予約済み。 使用できるように確保された、他の割り当て要求には使用できないメモリ ブロックです。 ただし、このメモリ ブロックがコミットされるまではデータを格納できません。

  - コミット済み。 物理ストレージに割り当てられたメモリ ブロックです。

- 仮想アドレス空間は、断片化することがあります。 断片化とは、アドレス空間に複数の空きブロック (ホールとも呼ばれます) がある状態です。 仮想メモリの割り当てが要求された場合、仮想メモリ マネージャーは、その割り当て要求を満たすのに十分な大きさの単一の空きブロックを見つけなければなりません。 2 GB の空き領域があっても、そのすべての空き領域が 1 つのアドレス ブロックの中にない場合、2 GB の領域を必要とする割り当ては失敗します。

- メモリが足りなくなるのは、予約する仮想アドレス空間が足りなくなった場合か、コミットする物理領域が足りなくなった場合です。

  ページ ファイルは、物理メモリの圧迫度 (物理メモリに対する需要) が低い場合にも使用されます。 最初に物理メモリの圧迫度が高まると、データを格納するための領域を確保するために物理メモリのデータの一部がページ ファイルにバックアップされますが、 そのデータは必要になるまでページングされないため、物理メモリの圧迫度が低い状況でページングが発生する可能性もあります。

## <a name="conditions-for-a-garbage-collection"></a>ガベージ コレクションの条件

ガベージ コレクションは、次のいずれかの条件に当てはまる場合に発生します。

- システムの物理メモリが少ない場合。 OS からのメモリ不足通知またはホストによって示されたメモリ不足のいずれかによって検出されます。

- マネージド ヒープで割り当てられたオブジェクトによって使用されているメモリが、許容されるしきい値を超える場合。 このしきい値は、プロセスの進行に合わせて絶えず調整されます。

- <xref:System.GC.Collect%2A?displayProperty=nameWithType> メソッドが呼び出された場合。 ほとんどの場合、ガベージ コレクターは継続して実行されるため、このメソッドを呼び出す必要はありません。 このメソッドは、主に特別な状況やテストで使用されます。

## <a name="the-managed-heap"></a>マネージド ヒープ

ガベージ コレクターは、CLR によって初期化された後、オブジェクトを格納および管理するためのメモリのセグメントを割り当てます。 オペレーティング システムのネイティブ ヒープに対し、このメモリのことをマネージド ヒープと呼びます。

マネージド ヒープはマネージド プロセスごとに割り当てられます。 プロセス内のすべてのスレッドは、同じヒープにオブジェクト用のメモリを割り当てます。

メモリを予約するために、ガベージ コレクターは Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) 関数を呼び出し、マネージド アプリケーション用のメモリのセグメントを一度に 1 つずつ予約します。 また、ガベージ コレクターは、必要に応じてセグメントを予約したり、Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) 関数を呼び出すことで (オブジェクトのセグメントをクリアしてから) セグメントを解放してオペレーティング システムに戻したりします。

> [!IMPORTANT]
> ガベージ コレクターによって割り当てらるセグメントのサイズは実装に固有であり、定期的な更新プログラムによる場合を含め、いつでも変更されることがあります。 アプリでは、セグメント サイズを推測することや、特定のセグメント サイズに依存することを絶対に避けてください。また、セグメントの割り当てに使用可能なメモリの量を構成しようとしてもなりません。

ヒープに割り当てられたオブジェクトが少ないほど、ガベージ コレクターの処理も少なくなります。 そのため、オブジェクトを割り当てるときに、必要な量より多く割り当てないようにしてください。たとえば、15 バイトしか必要がないときに 32 バイトの配列を割り当てないようにしてください。

ガベージ コレクションがトリガーされると、ガベージ コレクターは、使用されなくなったオブジェクトに占有されているメモリを解放します。 この解放プロセスでは、まとめて移動できるように有効なオブジェクトを圧縮し、使用されなくなったスペースを削除することで、ヒープを小さくします。 これにより、一緒に割り当てられたオブジェクトが同じマネージド ヒープにまとめられ、局所性が保持されます。

ガベージ コレクションの割り込みの動作 (頻度と期間) は、割り当てのボリュームとマネージド ヒープ上の残ったメモリの量によって決まります。

ヒープは、[大きなオブジェクト ヒープ](large-object-heap.md)と小さなオブジェクト ヒープの 2 つを累積したものと見なすことができます。

[大きなオブジェクト ヒープ](large-object-heap.md)には、85,000 バイトを超える非常に大きなオブジェクトが格納されます。 大きなオブジェクト ヒープの中のオブジェクトは、通常は配列になります。 インスタンス オブジェクトが極端に大きくなることはほとんどありません。

> [!TIP]
> オブジェクトの[しきい値サイズを構成](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold)すれば、大きなオブジェクト ヒープに移ることができます。

## <a name="generations"></a>ジェネレーション

ヒープは、有効期間が長いオブジェクトと有効期間が短いオブジェクトに対処できるようにジェネレーションにまとめられます。 ガベージ コレクションは主に、通常はヒープのごく一部だけを占有する有効期間が短いオブジェクトを解放する場合に発生します。 ヒープのオブジェクトのジェネレーションには次の 3 つがあります。

- **ジェネレーション 0**。 これは一番最初のジェネレーションで、有効期間が短いオブジェクトが格納されます。 有効期間が短いオブジェクトには、たとえば、テンポラリ変数などがあります。 ガベージ コレクションは、このジェネレーションで最も頻繁に発生します。

  新しく割り当てられたオブジェクトにより、新しいオブジェクトが生成されます。また、新しく割り当てられたオブジェクトは暗黙的にジェネレーション 0 コレクションになります。 ただし、大きなオブジェクトであれば、ジェネレーション 2 コレクションの大きなオブジェクト ヒープに移ります。

  ジェネレーション 0 では、ほとんどのオブジェクトがガベージ コレクションで解放され、次のジェネレーションには残りません。

- **ジェネレーション 1**。 このジェネレーションには有効期間が短いオブジェクトが格納されます。有効期間が短いオブジェクトと有効期間が長いオブジェクトの間のバッファーとして機能します。

- **ジェネレーション 2**。 このジェネレーションには、有効期間が長いオブジェクトが格納されます。 有効期間が長いオブジェクトには、たとえば、プロセスの存続期間を通じて有効な静的データを含むサーバー アプリケーションのオブジェクトなどがあります。

ガベージ コレクションは、条件に応じて特定のジェネレーションで発生します。 ジェネレーションのコレクションでは、そのジェネレーションとそれよりも前のすべてのジェネレーションのオブジェクトがコレクションの対象になります。 ジェネレーション 2 のガベージ コレクションは、すべてのジェネレーションのすべてのオブジェクト (つまり、マネージド ヒープのすべてのオブジェクト) を解放することから、フル ガベージ コレクションとも呼ばれます。

### <a name="survival-and-promotions"></a>存続と昇格

ガベージ コレクションで解放されなかったオブジェクトは残存オブジェクトと呼ばれ、次のジェネレーションに昇格されます。 ジェネレーション 0 のガベージ コレクションでごみではないと判断されたオブジェクトは、ジェネレーション 1 に昇格されます。ジェネレーション 1 のガベージ コレクションでごみではないと判断されたオブジェクトは、ジェネレーション 2 に昇格されます。ジェネレーション 2 のガベージ コレクションでごみではないと判断されたオブジェクトは、ジェネレーション 2 に残ります。

ジェネレーションでごみではないと判断される割合が高いことがガベージ コレクターで検出されると、そのジェネレーションに対する割り当てのしきい値が高くなります。 次のジェネレーションで十分なサイズの解放されたメモリが受け取られます。 CLR では、ガベージ コレクションを遅延させることでアプリケーションのワーキング セットが大きくなりすぎないようにすることと、ガベージ コレクションの実行頻度が多すぎないようにすることに注意して、それらの 2 つの優先事項のバランスを絶えず調整します。

### <a name="ephemeral-generations-and-segments"></a>短期のジェネレーションとセグメント

ジェネレーション 0 および 1 のオブジェクトは有効期間が短いことから、それらのジェネレーションのことを短期ジェネレーションと呼びます。

短期ジェネレーションは、短期セグメントと呼ばれるメモリ セグメントに割り当てる必要があります。 ガベージ コレクターによって新しいセグメントが取得されると、いずれも新しい短期セグメントになり、ジェネレーション 0 のガベージ コレクションで残ったオブジェクトが格納されます。 古い短期セグメントは新しいジェネレーション 2 のセグメントになります。

短期セグメントのサイズは、システムが 32 ビットと 64 ビットのどちらであるか、および実行されているガベージ コレクターの種類に応じて異なります。 既定の値を次の表に示します。

||32 ビット|64 ビット|
|-|-------------|-------------|
|ワークステーションの GC|16 MB|256 MB|
|サーバーの GC|64 MB|4 GB|
|サーバーの GC (論理 CPU が 4 個以上の場合)|32 MB|2 GB|
|サーバーの GC (論理 CPU が 8 個以上の場合)|16 MB|1 GB|

短期セグメントには、ジェネレーション 2 のオブジェクトも含めることができます。 ジェネレーション 2 のオブジェクトでは複数のセグメントを使用できます (プロセスでの必要に応じてメモリが許容できる限りいくつでも使用できます)。

短期ガベージ コレクションによって解放されるメモリの量は、短期セグメントのサイズまでに限られます。 解放されるメモリの量は、使用されなくなったオブジェクトに占有されていた領域に比例します。

## <a name="what-happens-during-a-garbage-collection"></a>ガベージ コレクションの実行時の動作

ガベージ コレクションには次のフェーズがあります。

- マーキング フェーズ。有効なすべてのオブジェクトを探し、そのリストを作成します。

- 再配置フェーズ。圧縮するオブジェクトへの参照を更新します。

- 圧縮フェーズ。使用されなくなったオブジェクトに占有されている領域を解放し、残ったオブジェクトを圧縮します。 圧縮フェーズでは、ガベージ コレクションで残ったオブジェクトをセグメントの後ろに移動します。

  ジェネレーション 2 のコレクションでは複数のセグメントを占有できるため、ジェネレーション 2 に昇格されたオブジェクトはより古いセグメントに移動できます。 ジェネレーション 1 とジェネレーション 2 の残存オブジェクトは、どちらもジェネレーション 2 に昇格されるため、別のセグメントに移動できます。

  通常、大きなオブジェクト ヒープ (LOH) は圧縮されません。これは、大きなオブジェクトをコピーするとパフォーマンスが低下するためです。 ただし、.NET Core と .NET Framework 4.5.1 以降では、<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> プロパティを使用して、大きなオブジェクト ヒープを必要に応じて圧縮できます。 また、LOH は、次のいずれかを指定することでハード上限が設定されるとき、自動的に圧縮されます。

  - コンテナーのメモリ上限、または
  - [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit) または [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent) ランタイム構成オプション

ガベージ コレクターは、次の情報に基づいてオブジェクトが有効かどうかを判断します。

- **スタック ルート**。 Just-In-Time (JIT) コンパイラとスタック ウォーカーによって提供されるスタック変数。 JIT の最適化では、スタック変数がガベージ コレクターに報告されるコードの領域が延長または短縮される可能性があります。

- **ガベージ コレクション ハンドル**。 マネージド オブジェクトを参照するハンドル。これらのハンドルは、ユーザー コードまたは共通言語ランタイムで割り当てることができます。

- **静的データ**。 他のオブジェクトを参照している可能性があるアプリケーション ドメインの静的オブジェクト。 静的オブジェクトはそれぞれのアプリケーション ドメインで追跡されます。

ガベージ コレクションが開始される前に、そのガベージ コレクションをトリガーしたスレッドを除くすべてのマネージド スレッドが中断されます。

次の図は、ガベージ コレクションを発生させて他のスレッドの中断を引き起こすスレッドを示しています。

![スレッドでガベージ コレクションをトリガーする場合](./media/gc-triggered.png)

## <a name="manipulate-unmanaged-resources"></a>アンマネージ リソースの操作

ガベージ コレクターではマネージド ヒープのメモリのみを追跡するため、マネージド オブジェクトでネイティブのファイル ハンドルを使用してアンマネージド オブジェクトを参照している場合は、そのアンマネージド オブジェクトを明示的に解放する必要があります。

マネージド オブジェクトのユーザーは、オブジェクトで使用されているネイティブ リソースを破棄できません。 そのため、クリーンアップを行うには、マネージド オブジェクトをファイナライズ可能にします。 ファイナライズは、オブジェクトが使用されなくなったときに実行するクリーンアップ アクションで構成されます。 マネージド オブジェクトが使用されなくなると、ファイナライザー メソッドで指定されたクリーンアップ アクションが実行されます。

ファイナライズ可能なオブジェクトが使用されなくなったことが検出されると、クリーンアップ アクションを実行するためにファイナライザーによってキューに入れられますが、オブジェクト自体は次のジェネレーションに昇格されます。 そのため、そのジェネレーションで次のガベージ コレクション (次回のガベージ コレクションではない場合もあります) が発生するまで、オブジェクトが解放されたかどうかは確認できません。

ファイナライズの詳細については、「<xref:System.Object.Finalize?displayProperty=nameWithType>」をご覧ください。

## <a name="workstation-and-server-garbage-collection"></a>ワークステーションとサーバーのガベージ コレクション

ガベージ コレクターは、さまざまなシナリオに対応できるように自動的に調整されます。 [構成ファイルの設定](../../core/run-time-config/garbage-collector.md#flavors-of-garbage-collection)を使用し、作業負荷の特性に基づいてガベージ コレクションの種類を設定できます。 CLR には、次の種類のガベージ コレクションが用意されています。

- ワークステーションのガベージ コレクション (GC) はクライアント アプリ向けに設計されています。 それはスタンドアロン アプリの既定の GC フレーバーです。 ホストされているアプリ (ASP.NET によってホストされるアプリなど) の場合、ホストにより既定の GC フレーバーが決定されます。

  ワークステーションのガベージ コレクションは、同時実行または非同時実行のどちらかで実行できます。 同時実行ガベージ コレクションでは、ガベージ コレクションの実行中にマネージド スレッドの操作を続けることができます。 .NET Framework 4 以降では、[同時実行ガベージ コレクション](#concurrent-garbage-collection)は、[バックグラウンド ガベージ コレクション](#background-workstation-garbage-collection)に置き換えられています。

- サーバーのガベージ コレクション。高いスループットとスケーラビリティが必要なサーバー アプリケーションを対象としたオプションです。

  - .NET Core では、サーバーのガベージ コレクションは、非同時実行ガベージ コレクションまたはバックグラウンド ガベージ コレクションである場合があります。

  - .NET Framework 4.5 以降のバージョンでは、サーバー ガベージ コレクションは非同時実行かバックグラウンドになります (バックグラウンド ガベージ コレクションは同時実行ガベージ コレクションに代わるものです)。 .NET Framework 4 以前のバージョンでは、サーバー ガベージ コレクションは非同時実行になります。

次の図は、サーバー上でガベージ コレクションを実行する専用のスレッドを示しています。

![サーバー ガベージ コレクションのスレッド](./media/gc-server.png)

### <a name="compare-workstation-and-server-garbage-collection"></a>ワークステーションとサーバーのガベージ コレクションを比較する

ワークステーションのガベージ コレクションにおける、スレッド処理とパフォーマンスについての注意点を次に示します。

- コレクションは、ガベージ コレクションをトリガーしたユーザー スレッドで、それと同じ優先順位で実行されます。 ユーザー スレッドは一般に通常の優先順位で実行されるため、その場合 (通常の優先順位のスレッドで実行された場合)、ガベージ コレクターの CPU 時間が他のスレッドと競合します。 (ネイティブ コードを実行するスレッドは、サーバーまたはワークステーションのガベージ コレクションでは中断されません)

- プロセッサが 1 つしかないコンピューターでは、[構成設定](../../core/run-time-config/garbage-collector.md#systemgcservercomplus_gcserver)に関係なく、常にワークステーションのガベージ コレクションが使用されます。

サーバーのガベージ コレクションにおける、スレッド処理とパフォーマンスについての注意点を次に示します。

- コレクションは、 `THREAD_PRIORITY_HIGHEST` の優先順位で実行される複数の専用スレッドで実行されます。

- ヒープおよびガベージ コレクションを実行するための専用スレッドは CPU ごとに 1 つずつ用意され、複数のヒープのコレクションが同時に行われます。 各ヒープには小さなオブジェクト ヒープと大きなオブジェクト ヒープがあり、どのヒープもユーザー コードからアクセスできます。 異なるヒープのオブジェクトを相互に参照できます。

- 複数のガベージ コレクション スレッドが連携して処理を行うため、同じサイズのヒープを処理した場合、サーバーのガベージ コレクションの方がワークステーションのガベージ コレクションよりも高速です。

- 一般に、サーバーのガベージ コレクションの方が、格納されるセグメントのサイズは大きくなります。 ただし、これは一般論に過ぎません。セグメントのサイズは実装に固有であり、変更されることがあります。 アプリをチューニングするときに、ガベージ コレクターによって割り当てられるセグメントのサイズに関して何らかの仮定をすることは避けてください。

- サーバーのガベージ コレクションでは、リソースが大量に消費されることがあります。 たとえば、プロセッサが 4 つのコンピューターで実行されているサーバー GC が 12 個のプロセスで使用されているとします。 すべてのプロセスで偶然、同時にガベージを回収すると、互いに干渉することになります。同じプロセッサで 12 のスレッドがスケジュールされるためです。 プロセスがアクティブの場合、すべてのプロセスでサーバー GC を使用することはお勧めしません。

実行するアプリケーションのインスタンスが数百に及ぶ場合は、同時実行ガベージ コレクションを無効にしてワークステーションのガベージ コレクションを使用することを検討してください。 これによって、コンテキストの切り替えが少なくなり、パフォーマンスが向上します。

## <a name="background-workstation-garbage-collection"></a>バックグラウンド ワークステーション ガベージ コレクション

バックグラウンド ワークステーションのガベージ コレクションでは、ジェネレーション 2 のコレクションの実行中に、必要に応じて短期ジェネレーション (0 および 1) のコレクションが行われます。 バックグラウンド ワークステーションのガベージ コレクションは専用のスレッドで実行され、ジェネレーション 2 コレクションにのみ適用されます。

バックグラウンド ガベージ コレクションは、既定で有効にされており、.NET Framework アプリケーションの [gcConcurrent>](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) 構成設定または .NET Core アプリの [System.GC.Concurrent](../../core/run-time-config/garbage-collector.md#systemgcconcurrentcomplus_gcconcurrent) 設定で有効または無効にすることができます。

> [!NOTE]
> [バックグラウンド ガベージ コレクション](#concurrent-garbage-collection)は同時実行ガベージ コレクションに取って代わり、.NET Framework 4 以降で利用できます。 .NET Framework 4 では、ワークステーション ガベージ コレクションのみでサポートされます。 .NET Framework 4.5 以降では、バックグラウンド ガベージ コレクションは、ワークステーションとサーバーのガベージ コレクションの両方で使用できます。

バックグラウンド ガベージ コレクションの実行中に行われる短期ジェネレーションに対するコレクションのことを、フォアグラウンド ガベージ コレクションと呼びます。 フォアグラウンド ガベージ コレクションが発生すると、マネージド スレッドはすべて中断されます。

バックグラウンド ガベージ コレクションの実行中にジェネレーション 0 に十分なオブジェクトが割り当てられていれば、CLR はジェネレーション 0 またはジェネレーション 1 のフォアグラウンド ガベージ コレクションを実行します。 バックグラウンド ガベージ コレクションの専用スレッドは、フォアグラウンド ガベージ コレクションの要求がないかどうかをセーフ ポイントで頻繁に確認します。 要求があると、バックグラウンド コレクションを中断して、フォアグラウンド ガベージ コレクションを実行します。 フォアグラウンド ガベージ コレクションが完了すると、バックグラウンド ガベージ コレクションの専用スレッドとユーザー スレッドが再開されます。

バックグラウンド ガベージ コレクションでは、バックグラウンド ガベージ コレクションの実行中に短期ガベージ コレクションが発生する可能性があるため、同時実行ガベージ コレクションによる割り当ての制限が解除されます。 バックグラウンド ガベージ コレクションでは、短期ジェネレーションの使用されなくなったオブジェクトを削除できます。 ジェネレーション 1 ガベージ コレクション中に必要になった場合、ヒープを拡張することもできます。

次の図は、ワークステーション上の別々の専用スレッドで実行されるバックグラウンド ガベージ コレクションを示しています。

![バックグラウンド ワークステーション ガベージ コレクション](./media/fundamentals/background-workstation-garbage-collection.png)

### <a name="background-server-garbage-collection"></a>バックグラウンド サーバー ガベージ コレクション

.NET Framework 4.5 以降では、サーバーのバックグラウンド ガベージ コレクションは、サーバーのガベージ コレクションの既定のモードです。

バックグラウンド サーバーのガベージ コレクションは、前のセクションで説明したワークステーションのバックグラウンド ガベージ コレクションと同様に機能しますが、いくつかの違いがあります。

- ワークステーションのバックグラウンド ガベージ コレクションでは専用のバックグラウンド ガベージ コレクション スレッドを 1 つ使用します。これに対して、サーバーのバックグラウンド ガベージ コレクションでは複数のスレッドを使用します。 通常、論理プロセッサごとに専用のスレッドが使用されます。

- ワークステーションのバックグラウンド ガベージ コレクション スレッドとは異なり、これらのスレッドはタイムアウトになりません。

次の図は、サーバー上の別々の専用スレッドで実行されるバックグラウンド ガベージ コレクションを示しています。

![バックグラウンド サーバー ガベージ コレクション](./media/fundamentals/background-server-garbage-collection.png)

## <a name="concurrent-garbage-collection"></a>同時実行ガベージ コレクション

> [!TIP]
> このセクションは次に適用されます。
>
> - ワークステーション ガベージ コレクションの .NET Framework 3.5 以前
> - サーバー ガベージ コレクションの .NET Framework 4 以前
>
> 後のバージョンでは、[バックグラウンド ガベージ コレクション](#background-workstation-garbage-collection)が同時実行ガベージに取って代わります。

ワークステーションまたはサーバーのガベージ コレクションでは、[同時実行ガベージ コレクションを有効にする](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)ことで、複数のスレッドを同時に実行できます。同時実行ガベージ コレクションでは、コレクションの実行中は、ほとんどの場合、ガベージ コレクションの処理を行う専用のスレッドが使用されます。 このオプションは、ジェネレーション 2 のガベージ コレクションにのみ影響します。ジェネレーション 0 と 1 の処理はすぐに終了するため、常に非同時実行で行われます。

同時実行ガベージ コレクションでは、コレクションの一時停止を最小限にすることで、インタラクティブ アプリケーションの応答性を高めることができます。 マネージド スレッドは、同時実行ガベージ コレクションのスレッドが実行されている間も、ほぼ常に処理を続けることができます。 そのため、ガベージ コレクションの実行中の一時停止が短くなります。

同時実行ガベージ コレクションは、専用のスレッドで実行されます。 既定では、CLR は、同時実行ガベージ コレクションを有効にしてワークステーションのガベージ コレクションを実行します。 これは、シングルプロセッサのコンピューターでもマルチプロセッサのコンピューターでも同じです。

次の図は、別々の専用のスレッドで実行される同時実行ガベージ コレクションを示しています。

![同時実行ガベージ コレクションのスレッド](./media/gc-concurrent.png)

## <a name="see-also"></a>関連項目

- [GC の構成オプション](../../core/run-time-config/garbage-collector.md)
- [ガベージ コレクション](index.md)
